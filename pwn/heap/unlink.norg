* Key concepts

@code c
    /* consolidate backward */
    if (!prev_inuse(p)) {
      prevsize = prev_size (p);
      size += prevsize;
      p = chunk_at_offset(p, -((long) prevsize));
      if (__glibc_unlikely (chunksize(p) != prevsize))
        malloc_printerr ("corrupted size vs. prev_size while consolidating");
      unlink_chunk (av, p);
    }

    static void
    unlink_chunk (mstate av, mchunkptr p)
    {
      if (chunksize (p) != prev_size (next_chunk (p)))
        malloc_printerr ("corrupted size vs. prev_size");

      mchunkptr fd = p->fd;
      mchunkptr bk = p->bk;

      if (__builtin_expect (fd->bk != p || bk->fd != p, 0))
        malloc_printerr ("corrupted double-linked list");

      fd->bk = bk;
      bk->fd = fd;
      // ...
    }
@end

When a freed chunk has `PREV_INUSE` bit unset, it will execute `unlink_chunk`,
which writes (of the prev chunk) `fd->bk` and `bk->fd`. If `fd` and `bk` of
prev chunk aren't pointing to heap, but instead pointing somewhere else (eg.
above chunk1 pointer in .bss, stack etc), it will overwrite chunk1 pointer with
memory slightly above chunk1 pointer, thus we can control chunk1 pointer and
subsequently attain write primitive.

* Unlink exploit

  @code c
  // here, p->fd has been overwritten to 0x55555, and p->bk has been overwritten to 0xdeadbeef
  // afterwards, p was allocated which called unlink()
  FD = p->fd; // FD = 0x555555
  BK = p->bk; // BK = 0xdeadbeef

  FD->bk = BK; // [0x555555 + 0x10 + 0x8] = 0xdeadbeef (0x10 is metadata, 0x8 is int64 fd)
  BK->fd = FD; // [0xdeadbeef + 0x10] = 0x555555 (0x10 is metadata)
  @end

  By overwriting the metadata of a freed chunk, we can cause its fd to point to arbitrary addresses, and insert our
  desired value into bk. Heap overflow makes this easy to do.

  The concept is to forge a fake chunk with fd and bk of our choosing. When
  another legit chunk adjacent to our fake chunk is freed, we want it to trigger
  the unlink macro, thus writing our desired values.

** Steps

   Malloc 2 chunks of size 0xa0 (or anything that can't fit in fastbins)

   @code
        ┌──────────────────────────────┐
   0x00 │ prev size |   size == 0xa1   │ -> chunk1
        │------------------------------│
   0x00 │ psize == 0x00 | size == 0xa0 │ -> fake chunk (free)
        │------------------------------│
   0x10 │   fd == 0xc0  |  bk == 0x00  │
        │──────────────────────────────│
   0x20 │             data             │
        │──────────────────────────────│
   0x30 │             ...              │
        │──────────────────────────────│
   0xb0 │             data             │
        │──────────────────────────────│
   0xc0 │    data   |   size == 0xa1   │ -> chunk2
        │──────────────────────────────│
   0xd0 │             ...              │
        │------------------------------│
  0x160 │             data             │
        └──────────────────────────────┘
   @end

   Forge a fake chunk in chunk1. This chunk should act like a free chunk with
   fd and bk pointing to the pointer to chunk1 - 0x10 and chunk - 0x18 (such
   that we can pass the unlink check).

   Lastly, for large chunks which go into the sorted largebin, they have to be
   sorted so in addition to fd and bk in the data section, they also have
   fd_nextsize and bk_nextsize, which point to the next larger and smaller free
   chunks. We want to set fd_nextsize to 0x0, so the program won't check for
   any larger chunks. (since this chunk by right will be the largest)

   @code
        +---------------------------------------+
   0x00 |     prev size    |    size == 0xa1    | -> chunk1
        |---------------------------------------|
   0x10 | prev size == 0x0 |    size == 0xa1    | -> fake chunk
        |---------------------------------------|
   0x20 | fd = 0x200 - 0x10 | bk = 0x200 - 0x18 |
        |---------------------------------------|
   0x30 |          fd_nextsize == 0x0           |
        |---------------------------------------|
   0x40 |                 ...                   |
        |---------------------------------------|
   0xb0 |                  data                 |
        |---------------------------------------|
   0xc0 |    data      |      size == 0xa1      | -> chunk2
        |---------------------------------------|
   0xd0 |                  ...                  |
        |---------------------------------------|
  0x160 |                  data                 |
        +---------------------------------------+
   @end

   With off-by-one or heap overflow, we can overwrite `prev_size` and
   `prev_in_use` of chunk2, so that when it's freed it will try to unlink fake
   chunk.

   @code
        +---------------------------------------+
   0x00 |     prev size    |    size == 0xa1    | -> chunk1
        |---------------------------------------|
   0x10 | prev size == 0x0 |    size == 0xa1    | -> fake chunk
        |---------------------------------------|
   0x20 | fd = 0x200 - 0x10 | bk = 0x200 - 0x18 |
        |---------------------------------------|
   0x30 |                 ...                   |
        |---------------------------------------|
   0xb0 |                  data                 |
        |---------------------------------------|
   0xc0 | prev size == 0xa0 |   size == 0xb0    | -> chunk2
        |---------------------------------------|
   0xd0 |                  ...                  |
        |---------------------------------------|
  0x160 |                  data                 |
        +---------------------------------------+
   @end

   Now, when we free chunk2, it thinks that fake chunk is freed, and will
   trigger the unlink() macro. Since `fake_chunk->bk` is pointing -0x10 from
   the pointer to chunk1, it will write `fake_chunk->fd` to pointer to chunk1.
   Thus, by writing to chunk1, we can change the write address and value.
